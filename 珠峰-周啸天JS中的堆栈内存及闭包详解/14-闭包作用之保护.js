/* 
[闭包]=>函数执行形成一个私有作用域,保护路面的私有变量不受外界的干扰,这种保护机制称之为闭包

=> 市面上的开发者 认为的闭包:形成一个不销毁的私有作用域(私有栈内存)才是闭包
 */

//=>闭包 :柯理化函数
/*  
function fn(){
     return function(){

     }
 }
 var f= fn(); 
 */
//=>闭包:惰性函数
/*  var utils = ( function(){
     return{

     }
 })();
  */

//=>闭包项目实战应用

//=>真是项目中为了保证js的性能(堆栈内存的性能优化),应该尽可能减少闭包的使用(不销毁的堆内存是耗性能的)

//1.闭包具有保护作用:保护私有变量不受外界的干扰
//=> 真是项目中,尤其是团队协作开发的时候 应当尽可能的较少全局变量的使用,以防止页面之前的冲突("全局变量污染"),那么此时我们完全可以把司机这一部分内容封装刀一个闭包中,让全局变量转换为私有变量

/* 
(function () {
    var n = 12;
    function fn() {}
})(); 
*/
//=>不仅如此,我们封装类库插件的时候,也会把自己的程序都存放到闭包中保护起来,防止和用户的程序冲突,但是我们有需要暴露一些方法给客户使用,这样我们如何处理?
    //1.JQ这种方式:把需要的方法抛到全局

    (function () {
        function jQuery() {
            //...
        }
        window.jQuery = window.$ = jQuery; //=>把需要拱外面使用的方法,通过window设置属性的方式暴露出去
    })();
    //jQuery;
    //$();
    //2.Zepto这种方式
    var Zepto=(function () {
       
            //...
        
        return $;
    })();
    //Zepto.xxx()
//2.闭包具有保存作用:形成不销毁的栈内存,把一些值得保存下来,方便后面的调取
